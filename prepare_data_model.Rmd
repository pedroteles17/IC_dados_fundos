---
title: "Preparing the Data"
output: html_notebook
---

# Packages

```{r, message=FALSE, warning=FALSE, results='hide'}
library(tidyverse)
library(readxl)
library(xts)
library(PerformanceAnalytics)
library(lubridate)
library(moments)

`%ni%` <- Negate(`%in%`)
```

# Import Data

Index return (IBX) and Risk free return (CDI):

```{r}
ind <- read.csv("indice.csv")
ind$Data <- as.Date(ind$Data)

rf <- read.csv("rf.csv")
rf$Data <- as.Date(rf$Data)

ind_rf <- ind %>%
  mutate(rf$Risk_free) %>%
  set_names("Data", "ret_ibx", "ret_rf")

nefin <- read_excel('fatores_nefin.xls') %>% 
  mutate(Data = make_date(year, month, day)) %>% 
  dplyr::select(!c(year, month, day)) %>% 
  dplyr::select(Data, everything()) %>% 
  dplyr::filter(Data <= '2021-12-30') %>% 
  slice(-1)

rm(ind, rf)
```

Funds' information:

```{r}
daily_data <- readRDS("dados_tratados_diarios.rds")

cadastral_info <- readRDS("dados_cadastrais.rds")
```

We have some outliers in our return database. We winsorize them.

```{r}
winsorize <- function (x, fraction = .01){
   lim <- quantile(x, probs=c(fraction, 1-fraction), na.rm = TRUE)
   
   x[ x < lim[1]] <- lim[1]
   x[ x > lim[2]] <- lim[2]
   
   return(x)
}

# Winsorizing
cota_diaria <- daily_data[['cota']]

winsorized_row <- vector('list', length = nrow(cota_diaria))
for (i in 1:nrow(cota_diaria)) {
  row_values <- do.call('c', cota_diaria[i, -1, drop = TRUE])
  
  winsorized_row[[i]] <- winsorize(row_values)
}

winsorized_data <- do.call('rbind', winsorized_row)

winsorized_data <- data.frame(Data = cota_diaria$Data, winsorized_data)

colnames(winsorized_data) <- colnames(cota_diaria) 

daily_data[['cota']] <- winsorized_data
```

```{r}
# We transform our columns so it can be used in a model
cadastral_info <- cadastral_info %>%
  dplyr::select(codigo, invest_qualificado, alavancado, data_inicio, prazo_conv_resg, prazo_pag_resg, aplic_min_inic, forma_condominio, fundo_cotas, fundo_exclusivo, data_inicio, data_fim) %>%
  mutate(invest_qualificado = ifelse(invest_qualificado == "N達o", 0, 1),
         alavancado = ifelse(alavancado == "N達o", 0, 1),
         prazo_conv_resg = as.numeric(str_sub(prazo_conv_resg, -3, -1)),
         prazo_pag_resg = as.numeric(str_sub(prazo_pag_resg, -3, -1)),
         prazo_receb_resg = prazo_conv_resg + prazo_pag_resg,
         aplic_min_inic = as.numeric(aplic_min_inic),
         forma_condominio = ifelse(forma_condominio == "Fechado", 0, 1),
         fundo_cotas = ifelse(fundo_cotas == "N達o", 0, 1),
         fundo_exclusivo = ifelse(fundo_exclusivo == "N達o", 0, 1))

# Soma funds are in one database but not in another one
diff_cadastral_daily <- setdiff(cadastral_info$codigo, colnames(daily_data[["cota"]]))

# We keep only the funds that are in both databases
cadastral_info <- cadastral_info %>% 
  dplyr::filter(codigo %ni% diff_cadastral_daily)
```

# Funds selection

* The fund needs to be active for at least 12 months;
* During these 12 months, the fund needs to have data for at least 90% of the days when the market was open;
* During the evaluation period the fund needs to have data for at least 90% of the days when the market was open;
* Incubation Bias: We eliminate funds with less than 10 million reais.

```{r}
# start_pre_date = when the estimation date will start
# end_pre_date = when the estimation date will end
# start_eval_date = when the evaluation date will start
# end_eval_date = when the evaluation date will end

get_funds_eleg <- function(start_pre_date, end_pre_date, start_eval_date, end_eval_date) {
  # First restrictions
  funds_eleg <- cadastral_info %>%
    dplyr::filter(data_inicio <= start_pre_date & (data_fim >= end_pre_date | is.na(data_fim))) %>% # First
    dplyr::select(codigo)

  # Second restriction
  funds_eleg <- daily_data[["cota"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(funds_eleg$codigo)) %>%
    dplyr::select_if(~ sum(is.na(.)) <= length(.)*0) %>% 
    dplyr::select_if(~ sum(. == 0) <= length(.)*0.1 )
  
  # Third restriction
  funds_eleg <- daily_data[["cota"]] %>%
    dplyr::filter(Data >= start_eval_date & Data <= end_eval_date) %>%
    dplyr::select(all_of(colnames(funds_eleg))) %>%
    dplyr::select_if(~ sum(is.na(.)) <= length(.)*0) %>% 
    dplyr::select_if(~ sum(. == 0) <= length(.)*0.1)
  
  # Fourth restriction
  assets_under_manag <- daily_data[["patrim_liq"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(colnames(funds_eleg)))
  assets_under_manag <- lapply(assets_under_manag, function(x) tail(x[!is.na(x)], 1))
  assets_under_manag <- do.call('c', assets_under_manag)
  assets_under_manag <- assets_under_manag[assets_under_manag > 10000]

  funds_eleg <- names(assets_under_manag)

  return(funds_eleg)
}
```

# Feature Creation

## Returns Statistics

```{r}

get_regres_info <- function(ret_xts, name){
  # 4 factor regression
  regres <- lm(I(ret_port - Risk_free) ~ Rm_minus_Rf + SMB + HML + WML, data = ret_xts)
  
  # Get regression coefficients
  regres_coef <- summary(regres)$coefficients
  ## Alpha t-stat
  alpha <- regres_coef[1, 3]
  ## Beta Market t-stat
  beta_mercado <- regres_coef[2, 3]
  ## Beta Size t-stat
  beta_size <- regres_coef[3, 3]
  ## Beta Value t-stat
  beta_value <- regres_coef[4, 3]
  ## Beta Mom t-stat
  beta_mom <- regres_coef[5, 3]
  
  ## R^2
  r_squared <- summary(regres)$r.squared
  
  ## Idiosyncratic Volatility
  ivol <- sd(regres$residuals)
  
  regres_info <- data.frame(
    alpha, beta_mercado, beta_size,
    beta_value, beta_mom, r_squared, 
    ivol
  )
  
  # Kurtosis 
  kurt_ret <- kurtosis(ret_xts$ret_port)
  
  # Israelsen Information Ratio (ttps://doi.org/10.1057/palgrave.jam.2240158)
  ER <- mean(ret_xts$ret_port - ret_xts$ind)
  SD <- sd(ret_xts$ret_port - ret_xts$ind)
  mir <- ER / (SD^(ER / abs(ER))) # Modified IR

  # CVaR
  cvar <- CVaR(ret_xts$ret_port)
  colnames(cvar) <- 'cvar'
  
  # Tracking Error
  track_error <- sd(ret_xts$ret_port - ret_xts$ind)
  
  stats <- data.frame(mir, cvar, track_error, kurt_ret)
  
  stats <- cbind(stats, regres_info)
  
  colnames(stats) <- paste(name, colnames(stats), sep = '_')
  
  return(stats)
}

get_stat_ret <- function(ret_port, ind, nefin) {
  
  ret_pre_xts <- data.frame(nefin, ret_port, ind)
  ret_xts <- xts(ret_pre_xts[,-1], ret_pre_xts$Data)
  
  # Full sample
  #full_info <- get_regres_info(ret_xts, 'full')
  
  # Short term momentum (Lagged one-month abnormal return)
  f_r2_1 <- first(last(ret_xts, '2 months'), '1 month')
  f_r2_1_info <- get_regres_info(f_r2_1, 'f_r2_1')
  
  # Momentum (Mean abnormal return from past 12 months)
  f_r12_2 <- first(last(ret_xts, '12 months'), '10 month')
  f_r12_2_info <- get_regres_info(f_r12_2, 'f_r12_2')
  
  # Short-term reversal (Prior month abnormal return)
  f_st_rev <- last(ret_xts, '1 month')
  f_st_rev_info <- get_regres_info(f_st_rev, 'f_st_rev')
  
  results_list <- list(f_r2_1_info, f_r12_2_info,
                       f_st_rev_info)
  
  results <- do.call('cbind', results_list)

  return(results)
}
```


## Fund's Statistics

```{r}
# Join all data frames
merge.all <- function(x, ..., by = "row.names") {
  L <- list(...)
  for (i in seq_along(L)) {
    x <- merge(x, L[[i]], by = by)
    rownames(x) <- x$Row.names
    x$Row.names <- NULL
  }
  return(x)
}

# start_pre_date = when the estimation date will start
# end_pre_date = when the estimation date will end
# funds_eleg = which funds meet all the restrictions (result from "get_funds_eleg")

get_funds_stat <- function(start_pre_date, end_pre_date, funds_eleg) {
  # Return Statistics
  funds_returns <- daily_data[["cota"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(funds_eleg))

  ind_rf_pre <- ind_rf %>% 
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date)
  
  nefin_pre <- nefin %>% 
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date)

  funds_stats <- lapply(funds_returns, function(x) get_stat_ret(x, ind_rf_pre$ret_ibx, nefin_pre))
  funds_stats <- do.call("rbind", funds_stats)

  # Assets Under Management
  funds_aum <- daily_data[["patrim_liq"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(funds_eleg))

  funds_aum <- lapply(funds_aum, function(x) tail(x[!is.na(x)], 1))

  funds_aum <- as.data.frame(do.call("rbind", funds_aum)) %>% 
    set_names("aum")

  # Inflow
  funds_inflow <- daily_data[["capt"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(funds_eleg))

  funds_inflow <- lapply(funds_inflow, function(x) sum(x, na.rm = TRUE))

  funds_inflow <- as.data.frame(do.call("rbind", funds_inflow)) %>% 
    set_names("inflow")

  # Outflow
  funds_outflow <- daily_data[["resg"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(funds_eleg))

  funds_outflow <- lapply(funds_outflow, function(x) sum(x, na.rm = TRUE))

  funds_outflow <- as.data.frame(do.call("rbind", funds_outflow)) %>% 
    set_names("outflow")
  
  # % Flow
  funds_flow_pct <- daily_data[["patrim_liq"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(funds_eleg))

  funds_flow_pct <- lapply(funds_flow_pct, function(x) head(x[!is.na(x)], 1))

  funds_flow_pct <- as.data.frame(do.call("rbind", funds_flow_pct)) %>% 
    set_names("aum") 
  
  funds_flow_pct <- merge.all(funds_flow_pct, funds_inflow, funds_outflow)
  
  funds_flow_pct <- funds_flow_pct %>% 
    mutate(pct_flow = (inflow - outflow) / aum) %>% 
    dplyr::select(pct_flow)

  # Number of shareholders
  funds_share_hold <- daily_data[["n_cotistas"]] %>%
    dplyr::filter(Data >= start_pre_date & Data <= end_pre_date) %>%
    dplyr::select(all_of(funds_eleg))

  funds_share_hold <- lapply(funds_share_hold, function(x) tail(x[!is.na(x)], 1))

  funds_share_hold <- as.data.frame(do.call("rbind", funds_share_hold)) %>% 
    set_names("shareholders")

  funds_stats <- merge.all(funds_stats, funds_aum, funds_inflow, funds_outflow, funds_flow_pct, funds_share_hold)

  return(funds_stats)
}
```

# Dependent Variable

```{r}
alpha_eval <- function(ret, nefin){
  regres <- lm(I(ret - Risk_free) ~ Rm_minus_Rf + SMB + HML + WML, data = nefin)
  
  alpha <-  summary(regres)$coefficients[1,1]
  
  return(alpha)
}

abnormal_ret <- function(ret, nefin){
  regres <- lm(I(ret - Risk_free) ~ Rm_minus_Rf + SMB + HML + WML, data = nefin)
  
  regres_coefs <- summary(regres)$coefficients[-1, 1]
  
  return(regres_coefs)
}

# start_eval_date = when the evaluation date will start
# end_eval_date = when the evaluation date will end
# funds_eleg = which funds meet all the restrictions (result from "get_funds_eleg")

get_dependent_var <- function(start_eval_date, end_eval_date, start_pre_date, end_pre_date, funds_eleg, type) {
  if(type == 'classif_closed'){
      # Determine which funds closed between the start and end of the evaluation period
    funds_closed <- cadastral_info %>%
      dplyr::filter(codigo %in% funds_eleg) %>%
      mutate(closed = ifelse(data_fim < start_eval_date | data_fim > end_eval_date | is.na(data_fim), 0, 1)) %>%
      dplyr::select(codigo, closed) %>%
      `rownames<-`(.$codigo) %>%
      dplyr::select(!codigo) %>% 
      set_names('dep_var') # The name must be the same for generalization purposes
    
    return(funds_closed)

  } else if(type == 'classif_outperfomance') {
    funds_returns_eval <- daily_data[['cota']] %>% 
       dplyr::filter(Data > start_eval_date & Data <= end_eval_date) %>%
       dplyr::select(all_of(funds_eleg)) 
    
    ind_rf_eval <- ind_rf %>% 
      dplyr::filter(Data > start_eval_date & Data <= end_eval_date)
    
    funds_stats_eval <- lapply(funds_returns_eval, function(x) prod(1 + (x - ind_rf_eval$ret_ibx), na.rm = TRUE) - 1)
    
    funds_stats_eval <- do.call('c', funds_stats_eval)
    
    funds_stats_eval <- as.data.frame(ifelse(funds_stats_eval > 0, 1, 0)) %>% set_names('dep_var') # The name must be the same for generalization purposes
    
    return(funds_stats_eval)
  } else if(type == 'regres_ab_ret'){
    # Estimation data
    funds_returns_estim <- daily_data[['cota']] %>% 
      dplyr::filter(Data > start_pre_date & Data <= end_pre_date) %>%
      dplyr::select(all_of(funds_eleg))
    
    nefin_estim <- nefin %>% 
      dplyr::filter(Data > start_pre_date & Data <= end_pre_date)
     
    # Funds' coefficients in the estimation data
    funds_coefs <- lapply(funds_returns_estim, function(x) abnormal_ret(x, nefin_estim))
    
    # Evaluation data
    funds_returns_eval <- daily_data[['cota']] %>% 
      dplyr::filter(Data >= start_eval_date & Data <= end_eval_date) %>%
      dplyr::select(all_of(funds_eleg))
    
    funds_returns_eval <- apply(funds_returns_eval, 2, function(x) prod(1 + x) - 1)
    
    nefin_eval <- nefin %>% 
      dplyr::filter(Data >= start_eval_date & Data <= end_eval_date) %>% 
      dplyr::select(Rm_minus_Rf, SMB, HML, WML) 
    
    nefin_eval <- apply(nefin_eval, 2, function(x) prod(1 + x) - 1)
    
    # Funds' expected return
    funds_exp_ret <- lapply(funds_coefs, function(x) sum(nefin_eval * x))
    funds_exp_ret <- unlist(funds_exp_ret)
    
    # Funds' abnormal return
    funds_abn_ret <- data.frame(dep_var = funds_returns_eval - funds_exp_ret)
    
    return(funds_abn_ret)
  } else if(type == 'regres_alpha'){
    funds_returns_eval <- daily_data[['cota']] %>% 
      dplyr::filter(Data > start_eval_date & Data <= end_eval_date) %>%
      dplyr::select(all_of(funds_eleg))
    
    nefin_eval <- nefin %>% 
      dplyr::filter(Data > start_eval_date & Data <= end_eval_date)
    
    funds_abn_ret <- lapply(funds_returns_eval, function(x) alpha_eval(x, nefin_eval))
    
    funds_abn_ret <- as.data.frame(do.call('rbind', funds_abn_ret)) %>% set_names('dep_var')
    
  } else if(type == 'regres_flows'){
    funds_flow <- daily_data[['capt_liq']] %>% 
      dplyr::filter(Data >= start_eval_date & Data <= end_eval_date) %>%
      dplyr::select(all_of(funds_eleg)) 
    
    funds_flow <- lapply(funds_flow, function(x) sum(x, na.rm = TRUE))
    
    funds_flow <- as.data.frame(do.call('rbind', funds_flow)) %>% set_names('dep_var') # The name must be the same for generalization purposes 
    
    return(funds_flow)
  } else if(type == 'classif_flows'){
    funds_flow <- daily_data[['capt_liq']] %>% 
      dplyr::filter(Data >= start_eval_date & Data <= end_eval_date) %>%
      dplyr::select(all_of(funds_eleg)) 
    
    funds_flow <- lapply(funds_flow, function(x) sum(x, na.rm = TRUE))
    
    funds_flow <- as.data.frame(do.call('rbind', funds_flow)) %>% 
      set_names('dep_var') %>% # The name must be the same for generalization purposes
      mutate(dep_var = ifelse(dep_var > 0, 1, 0))
    
    return(funds_flow)
  } else if(type == 'alpha_abn'){
    types <- list('regres_alpha', 'regres_ab_ret')
    
    funds_info <- lapply(types, function(x) get_dependent_var(start_eval_date, end_eval_date, funds_eleg, x))
    
    funds_info <- do.call('cbind', funds_info) %>%
      set_names(c('regres_alpha', 'regres_ab_ret'))

    return(funds_info)
  }

}
```

# Wrapper Function

```{r}
get_final_df <- function(start_pre_date, end_pre_date, start_eval_date, end_eval_date, type) {
  
  # Which funds meet all the requirements?
  funds_eleg <- get_funds_eleg(start_pre_date, end_pre_date, start_eval_date, end_eval_date)

  # Get the data regarding each funds
  funds_ret_stat <- get_funds_stat(start_pre_date, end_pre_date, funds_eleg) %>% 
    mutate(codigo = rownames(.), .before = 1)

  # Calculate how old was the fund at the end of the estimation period and get the cadastral information
  funds_cadastral <- cadastral_info %>%
    dplyr::filter(codigo %in% funds_eleg) %>%
    mutate(age = time_length(difftime(as.Date(end_pre_date), as.Date(data_inicio)), "years")) %>% # How old
    dplyr::select(!c(data_inicio, data_fim, prazo_conv_resg, prazo_pag_resg)) # cadastral information

  # Get our dependent variable
  funds_dep_variable <- get_dependent_var(start_eval_date, end_eval_date, start_pre_date, end_pre_date, funds_eleg, type) %>% 
    mutate(codigo = rownames(.), .before = 1)

  funds_stat <- merge(merge(funds_dep_variable, funds_ret_stat, by = 'codigo'), funds_cadastral, by = 'codigo') 

  return(funds_stat)
}
```

# Get clean data 

```{r message=FALSE, warning=FALSE, results='hide'}
# How many months should we look back to calculate the statistics?
look_back <- 12
# How many months should we consider for making a prediction?
pred_n_months <- 1
# With what frequency (in months) should we make a new prediction?
rebalance_n_months <- 1
# When to start making a prediction
start_eval_date <- as.Date("2005-01-01") # In fact, 2005-02-01, because we sum 1  month
# What type of dependent variable we want? ('all' with we want all of them)
type = 'regres_ab_ret'

n_months <- interval(start_eval_date %m-% days(1) %m+% months(pred_n_months), as.Date("2021-12-31")) %/% months(rebalance_n_months)
final_df <- vector("list", length = n_months)
for (i in 1:n_months) {
  start_eval_date <- as.Date(start_eval_date) %m+% months(rebalance_n_months)
  end_pre_date <- start_eval_date %m-% days(1)
  start_pre_date <- as.Date(end_pre_date) %m-% months(look_back)
  end_eval_date <- as.Date(start_eval_date) %m+% months(pred_n_months) %m-% days(1)

  final_df[[i]] <- get_final_df(start_pre_date, end_pre_date, start_eval_date, end_eval_date, type) %>%
    mutate(year = year(start_eval_date), month = month(start_eval_date))
}

final_df <- do.call("rbind", final_df) %>% 
  as.data.frame(row.names = 1:nrow(.))
```

```{r}
print('NAs:')
apply(final_df, 2, function(x) sum(is.na(x)))

print('Infinite')
apply(final_df, 2, function(x) sum(is.infinite(x)))
```


```{r}
summary(final_df)
```


```{r}
write.csv(final_df, 'data_modelling.csv', row.names = FALSE)
```

